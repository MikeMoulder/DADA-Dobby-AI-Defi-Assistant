<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DADA — Dobby AI DeFi Assistant</title>

  <link rel="icon" type="image/png" href="dobby-logo.png">
  <link rel="shortcut icon" type="image/png" href="dobby-logo.png">
<link rel="apple-touch-icon" href="dobby-logo.png">
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Picovoice Web SDK -->
  <script src="https://unpkg.com/@picovoice/web-voice-processor@4.0.15/dist/iife/index.js"></script>
  <script src="https://unpkg.com/@picovoice/porcupine-web@3.0.5/dist/iife/index.js"></script>
  <script src="https://unpkg.com/@picovoice/leopard-web@2.0.5/dist/iife/index.js"></script>
  
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            primary: {
              50: '#f0f9ff',
              100: '#e0f2fe',
              500: '#0ea5e9',
              600: '#0284c7',
              700: '#0369a1',
              900: '#0c4a6e'
            }
          },
          animation: {
            'fade-in': 'fadeIn 0.5s ease-out',
            'slide-up': 'slideUp 0.3s ease-out',
            'pulse-ring': 'pulseRing 2s cubic-bezier(0.455, 0.03, 0.515, 0.955) infinite',
            'typing': 'typing 1.5s ease-in-out infinite',
            'float': 'float 3s ease-in-out infinite'
          },
          keyframes: {
            fadeIn: {
              '0%': { opacity: '0', transform: 'translateY(10px)' },
              '100%': { opacity: '1', transform: 'translateY(0)' }
            },
            slideUp: {
              '0%': { opacity: '0', transform: 'translateY(20px)' },
              '100%': { opacity: '1', transform: 'translateY(0)' }
            },
            pulseRing: {
              '0%': { transform: 'scale(0.33)', opacity: '1' },
              '80%, 100%': { transform: 'scale(2.33)', opacity: '0' }
            },
            typing: {
              '0%, 60%, 100%': { opacity: '1' },
              '30%': { opacity: '0' }
            },
            float: {
              '0%, 100%': { transform: 'translateY(0px)' },
              '50%': { transform: 'translateY(-10px)' }
            }
          }
        }
      }
    }
  </script>
  <style>
    /* Custom scrollbar */
    .custom-scrollbar::-webkit-scrollbar { width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { 
      background: transparent; 
      border-radius: 10px; 
    }
    .custom-scrollbar::-webkit-scrollbar-thumb { 
      background: rgba(156, 163, 175, 0.5); 
      border-radius: 10px;
      transition: background 0.2s;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover { 
      background: rgba(156, 163, 175, 0.8); 
    }
    .dark .custom-scrollbar::-webkit-scrollbar-thumb { 
      background: rgba(75, 85, 99, 0.6); 
    }
    .dark .custom-scrollbar::-webkit-scrollbar-thumb:hover { 
      background: rgba(75, 85, 99, 0.9); 
    }

    /* Listening pulse effect */
    .pulse-ring {
      position: relative;
    }
    .pulse-ring::before {
      content: '';
      position: absolute;
      inset: -4px;
      border-radius: 50%;
      border: 2px solid rgb(16, 185, 129);
      animation: pulseRing 2s infinite;
    }

    /* Typing indicator */
    .typing-dots span {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      display: inline-block;
      margin: 0 1px;
      animation: typing 1.4s infinite ease-in-out both;
    }
    .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
    .typing-dots span:nth-child(2) { animation-delay: -0.16s; }

    /* Gradient backgrounds */
    .gradient-bg {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    .dark .gradient-bg {
      background: linear-gradient(135deg, #2d1b69 0%, #11998e 100%);
    }

    /* Glass morphism effect */
    .glass {
      background: rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.18);
    }
    .dark .glass {
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Shimmer effect for loading */
    .shimmer {
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
    }
    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }

    /* Dobby logo styles */
    .dobby-logo {
      width: 48px;
      height: 48px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    .dobby-logo-small {
      width: 40px;
      height: 40px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
  </style>
</head>
<body class="transition-colors duration-300 bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100">
  <!-- App Shell -->
  <div class="min-h-screen flex flex-col relative gradient-bg">
    <!-- Floating background elements -->
    <div class="fixed inset-0 overflow-hidden pointer-events-none">
      <div class="absolute top-20 left-10 w-20 h-20 bg-white/10 rounded-full animate-float"></div>
      <div class="absolute top-40 right-20 w-16 h-16 bg-white/5 rounded-full animate-float" style="animation-delay: 1s;"></div>
      <div class="absolute bottom-40 left-1/4 w-12 h-12 bg-white/10 rounded-full animate-float" style="animation-delay: 2s;"></div>
    </div>

    <!-- Top Bar -->
    <header class="sticky top-0 z-50 glass border-b border-white/20">
      <div class="max-w-6xl mx-auto px-4 py-4 flex items-center gap-4">
        <!-- Logo & Title -->
        <div class="flex items-center gap-3">
          <img 
            src="dobby-logo.png" 
            alt="Dobby Logo" 
            class="dobby-logo-small animate-float"
            onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'"
          />
          <div class="w-10 h-10 bg-emerald-500 rounded-2xl flex items-center justify-center text-white text-lg animate-float" style="display: none;">
            🤖
          </div>
          <div>
            <h1 class="font-bold text-xl text-white">DADA</h1>
            <p class="text-white/80 text-sm">Dobby AI DeFi Assistant</p>
          </div>
        </div>

        <!-- Status & Controls -->
        <div class="flex items-center gap-4 ml-auto">
          <!-- Mic Status -->
          <div class="flex items-center gap-2">
            <div id="micBadge" class="w-3 h-3 rounded-full bg-gray-300 transition-all duration-300" title="Mic idle"></div>
            <span class="text-white/80 text-sm font-medium" id="voiceStatus">Initializing...</span>
          </div>

          <!-- Always Listening Toggle -->
          <label class="flex items-center gap-2 cursor-pointer select-none text-white/80 text-sm">
            <div class="relative">
              <input id="toggleAlways" type="checkbox" class="sr-only peer" />
              <div class="w-11 h-6 bg-white/20 rounded-full peer-checked:bg-emerald-500 transition-all duration-300"></div>
              <div class="absolute left-1 top-1 w-4 h-4 bg-white rounded-full transition-transform duration-300 peer-checked:translate-x-5"></div>
            </div>
            <span>Always listening</span>
          </label>

          <!-- Theme Toggle -->
          <button id="themeToggle" class="w-9 h-9 bg-white/20 hover:bg-white/30 rounded-xl flex items-center justify-center text-white transition-all duration-300 hover:scale-105">
            <span class="text-lg">🌙</span>
          </button>

          <!-- Listen Button -->
          <button id="btnListen" class="px-4 py-2 bg-emerald-500 hover:bg-emerald-600 text-white rounded-xl font-medium transition-all duration-300 hover:scale-105 shadow-lg hover:shadow-emerald-500/25" disabled>
            Initializing...
          </button>
        </div>
      </div>
    </header>

    <!-- Messages Container -->
    <main id="chat" class="flex-1 max-w-6xl mx-auto w-full px-4 py-8 space-y-6 overflow-y-auto custom-scrollbar">
      <!-- Welcome message -->
      <div class="flex gap-4 animate-fade-in">
        <img 
          src="dobby-logo.png" 
          alt="Dobby Logo" 
          class="dobby-logo shadow-lg"
          onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'"
        />
        <div class="w-12 h-12 bg-emerald-500 rounded-2xl flex items-center justify-center text-white text-xl shadow-lg" style="display: none;">
          🤖
        </div>
        <div class="max-w-[85%] glass rounded-3xl p-6 shadow-xl">
          <div class="text-white leading-relaxed">
            <div class="font-semibold text-lg mb-2">Welcome to DADA! ✨</div>
            <p class="opacity-90">
              I'm <strong>Dobby</strong>, your AI-powered DeFi assistant with advanced voice recognition. Say <em>"Hi Dobby"</em> to wake me up, 
              then ask about crypto prices and I'll provide live data with AI-powered insights!
            </p>
            <div class="mt-4 text-sm opacity-75">
              💡 Try: "Hi Dobby" → "What's the price of Bitcoin?" or "Show me Ethereum analysis"
            </div>
          </div>
        </div>
      </div>
    </main>

    <!-- Typing Indicator (hidden by default) -->
    <div id="typingIndicator" class="max-w-6xl mx-auto w-full px-4 hidden">
      <div class="flex gap-4 animate-slide-up">
        <img 
          src="dobby-logo.png" 
          alt="Dobby Logo" 
          class="dobby-logo shadow-lg"
          onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'"
        />
        <div class="w-12 h-12 bg-emerald-500 rounded-2xl flex items-center justify-center text-white text-xl shadow-lg" style="display: none;">
          🤖
        </div>
        <div class="glass rounded-3xl p-6 shadow-xl">
          <div class="flex items-center gap-2 text-white">
            <span class="opacity-75">Dobby is analyzing</span>
            <div class="typing-dots">
              <span class="bg-white/70"></span>
              <span class="bg-white/70"></span>
              <span class="bg-white/70"></span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Input Area -->
    <footer class="border-t border-white/20 glass backdrop-blur-xl">
      <div class="max-w-6xl mx-auto px-4 py-4">
        <div class="flex items-center gap-3">
          <div class="flex-1 relative">
            <input 
              id="textInput" 
              class="w-full px-6 py-4 bg-white/90 dark:bg-gray-800/90 border border-white/30 rounded-2xl focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-transparent transition-all duration-300 text-gray-900 dark:text-gray-100 placeholder-gray-500 dark:placeholder-gray-400" 
              placeholder="Type: Hey Dobby, what's the price of ETH?" 
            />
            <div class="absolute right-4 top-1/2 transform -translate-y-1/2 text-gray-400">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
              </svg>
            </div>
          </div>
          <button id="btnSend" class="px-6 py-4 bg-emerald-500 hover:bg-emerald-600 text-white rounded-2xl font-medium transition-all duration-300 hover:scale-105 shadow-lg hover:shadow-emerald-500/25">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
            </svg>
          </button>
        </div>
      </div>
    </footer>
  </div>

  <script>
    // ====== Configuration ======
    const DOBBY_KEY = 'fw_3ZRfi3Krcv5qJd58E8nCzeYM'; 
    const PICOVOICE_ACCESS_KEY = 'FbpeEFVKhUgHQlFwE/hZ6rgNs9s3YkPxv7XaepgQP01lQtr3RNKQQQ==';

    // ====== Theme Management ======
    const themeToggle = document.getElementById('themeToggle');
    const html = document.documentElement;
    
    // Initialize theme
    const savedTheme = window.localStorage?.getItem('theme') || 'light';
    html.classList.toggle('dark', savedTheme === 'dark');
    updateThemeIcon();
    
    themeToggle.addEventListener('click', () => {
      const isDark = html.classList.contains('dark');
      html.classList.toggle('dark');
      if (window.localStorage) {
        window.localStorage.setItem('theme', isDark ? 'light' : 'dark');
      }
      updateThemeIcon();
    });
    
    function updateThemeIcon() {
      const isDark = html.classList.contains('dark');
      themeToggle.innerHTML = `<span class="text-lg">${isDark ? '☀️' : '🌙'}</span>`;
    }

    // ====== Voice Recognition Setup (Picovoice) ======
    const synth = window.speechSynthesis;
    
    let porcupine = null;
    let leopard = null;
    let webVoiceProcessor = null;
    let isInitialized = false;

    const state = {
      always: false,
      listening: false,
      waitingForCommand: false,
      wake: 'hey dobby',
      vsCurrency: 'usd',
      wakeWordDetected: false
    };

    // ====== UI Elements ======
    const chat = document.getElementById('chat');
    const btnListen = document.getElementById('btnListen');
    const toggleAlways = document.getElementById('toggleAlways');
    const micBadge = document.getElementById('micBadge');
    const voiceStatus = document.getElementById('voiceStatus');
    const input = document.getElementById('textInput');
    const btnSend = document.getElementById('btnSend');
    const typingIndicator = document.getElementById('typingIndicator');

    // ====== Picovoice Initialization ======
    async function initializePicovoice() {
      try {
        // Check if Picovoice libraries are loaded
        if (typeof PorcupineWeb === 'undefined' || typeof LeopardWeb === 'undefined' || typeof WebVoiceProcessor === 'undefined') {
          console.warn('Picovoice libraries not available, falling back to Web Speech API');
          initializeWebSpeechAPI();
          return;
        }

        if (PICOVOICE_ACCESS_KEY === 'YOUR_PICOVOICE_ACCESS_KEY_HERE') {
          console.warn('Picovoice Access Key not configured, falling back to Web Speech API');
          initializeWebSpeechAPI();
          return;
        }

        // Initialize Porcupine (Wake Word Detection)
        porcupine = await PorcupineWeb.PorcupineWorkerFactory.create(
          PICOVOICE_ACCESS_KEY,
          [PorcupineWeb.BuiltinKeyword.HEY_SIRI], // Using built-in wake word as placeholder
          [0.5], // Sensitivity
          { processErrorCallback: handlePorcupineError }
        );

        // Initialize Leopard (Speech-to-Text)
        leopard = await LeopardWeb.LeopardWorkerFactory.create(
          PICOVOICE_ACCESS_KEY,
          { processErrorCallback: handleLeopardError }
        );

        // Initialize Web Voice Processor
        webVoiceProcessor = await WebVoiceProcessor.WebVoiceProcessor.init({
          engines: [porcupine, leopard],
          start: false,
        });

        // Set up event handlers
        porcupine.onmessage = handlePorcupineDetection;
        leopard.onmessage = handleLeopardTranscription;

        isInitialized = true;
        btnListen.disabled = false;
        btnListen.textContent = 'Start Listening';
        updateVoiceStatus('Voice Ready (Picovoice)');

        console.log('Picovoice initialized successfully');
      } catch (error) {
        console.error('Picovoice initialization error:', error);
        console.log('Falling back to Web Speech API');
        initializeWebSpeechAPI();
      }
    }

    // ====== Web Speech API Fallback ======
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;

    function initializeWebSpeechAPI() {
      if (!SpeechRecognition) {
        handleInitializationError(new Error('No speech recognition available'));
        return;
      }

      recognition = new SpeechRecognition();
      recognition.lang = 'en-US';
      recognition.continuous = true;
      recognition.interimResults = false;

      recognition.onresult = (e) => {
        const last = e.results[e.results.length - 1][0].transcript.trim();
        console.log('Heard:', last);
        handleWebSpeechTranscript(last);
      };

      recognition.onstart = () => {
        state.listening = true;
        updateMicBadge(true, state.waitingForCommand);
        btnListen.textContent = 'Stop Listening';
      };

      recognition.onend = () => {
        state.listening = false;
        if (!state.waitingForCommand) {
          updateMicBadge(false);
          btnListen.textContent = 'Start Listening';
        }
        
        // Auto-restart if in always mode and not waiting for command
        if (state.always && !state.waitingForCommand) {
          setTimeout(() => {
            startWebSpeechListening();
          }, 100);
        }
      };

      recognition.onerror = (e) => {
        console.log('Speech recognition error:', e.error);
        if (e.error === 'no-speech' && state.always) {
          // Auto-restart on no-speech error in always mode
          setTimeout(() => {
            if (state.always && !state.listening) {
              startWebSpeechListening();
            }
          }, 1000);
        }
      };

      isInitialized = true;
      btnListen.disabled = false;
      btnListen.textContent = 'Start Listening';
      updateVoiceStatus('Voice Ready (Web Speech)');
      console.log('Web Speech API initialized as fallback');
    }

      // ...existing code...

// ...existing code...

// Update handleWebSpeechTranscript to strictly stop listening after a command is detected,
// and only resume after Dobby finishes speaking (if always listening is enabled).

function handleWebSpeechTranscript(raw) {
  // IMMEDIATELY stop listening when any user input is detected
  stopListening();

  const heard = raw.toLowerCase().trim();
  const words = heard.split(/\s+/);
  const firstWord = words[0];
  const wakeWords = ["hey", "a", "i", "hello", "hi"];

  // If waiting for command, process it
  if (state.waitingForCommand) {
    state.waitingForCommand = false;

    // Custom: Update user message for "a" or "i"
    let displayText = raw;
    if (firstWord === "a") {
      displayText = "Hey Dobby, " + words.slice(1).join(" ");
    } else if (firstWord === "i") {
      displayText = "Hi Dobby, " + words.slice(1).join(" ");
    }

    addUserMessage(displayText);
    processCommand(raw); // This will handle speaking and resuming listening
    return;
  }

  if (!wakeWords.includes(firstWord)) return;

  let cmd = words.slice(1).join(" ").trim();

  if (!cmd || cmd.length < 2) {
    // Just a wake word without command
    let displayText = firstWord;
    if (firstWord === "a") {
      displayText = "Hey Dobby,";
    } else if (firstWord === "i") {
      displayText = "Hi Dobby,";
    }

    addUserMessage(displayText);
    const greeting = "Hi there! What can I help you with today?";
    addBotMessage(greeting);

    // Don't set isAnsweringUser = true for greeting, we want to wait for command
    speak(greeting, () => {
      // After greeting, start listening for the actual command
      state.waitingForCommand = true;
      updateMicBadge(true, true);
      if (state.always || state.listening) {
        startListening();
      }
    }, false);
    return;
  }

  // Wake word + command in one phrase
  let displayText = raw;
  if (firstWord === "a") {
    displayText = "Hey Dobby, " + cmd;
  } else if (firstWord === "i") {
    displayText = "Hi Dobby, " + cmd;
  }

  addUserMessage(displayText);
  processCommand(cmd); // This will handle speaking and resuming listening
}

// ...existing code...

// Add a flag to track if Dobby is currently speaking an answer
let isDobbySpeaking = false;

// Update the speak function to set and clear this flag
function speak(text, onFinish, isAnsweringUser = false) {
  try {
    if (state.listening) stopListening();
    isDobbySpeaking = true;

    const utterance = new SpeechSynthesisUtterance(text);
    utterance.rate = 1.0; // 0.9 is a bit slow, 1.0 is more natural
    utterance.pitch = 1.1; // Slightly higher pitch can sound friendlier

    // Try to select a more natural voice (e.g., Google, Microsoft, etc.)
    const preferredVoices = ['Google UK English Male', 'Google US English', 'Microsoft David', 'Microsoft Jenny'];
    const voices = window.speechSynthesis.getVoices();
    utterance.voice = voices.find(v => preferredVoices.includes(v.name)) || voices[0];

    utterance.lang = 'en-US';
    synth.cancel();
    synth.speak(utterance);

    utterance.onend = () => {
      isDobbySpeaking = false;
      if (typeof onFinish === "function") onFinish();
      if (state.always && isInitialized && isAnsweringUser) {
        setTimeout(() => { startListening(); }, 300);
      }
    };
    utterance.onerror = (error) => {
      isDobbySpeaking = false;
      if (typeof onFinish === "function") onFinish();
      if (state.always && isInitialized && isAnsweringUser) {
        setTimeout(() => { startListening(); }, 300);
      }
    };
  } catch (error) {
    isDobbySpeaking = false;
    if (typeof onFinish === "function") onFinish();
    if (state.always && isInitialized && isAnsweringUser) {
      setTimeout(() => { startListening(); }, 300);
    }
  }
}
    function startWebSpeechListening() {
      try { 
        if (recognition && !state.listening) {
          recognition.start(); 
        }
      } catch (e) {
        console.log('Recognition start error:', e);
      } 
    }
    
    function stopWebSpeechListening() { 
      try { 
        if (recognition) {
          recognition.stop(); 
        }
      } catch (e) {
        console.log('Recognition stop error:', e);
      } 
    }

    function handleInitializationError(error) {
      let message = 'Voice recognition not available';
      
      if (error.message.includes('Access Key')) {
        message = 'Please configure Picovoice API key';
      } else if (error.message.includes('microphone')) {
        message = 'Microphone access denied';
      }
      
      updateVoiceStatus(message);
      btnListen.textContent = message;
      btnListen.disabled = true;
      btnListen.classList.add('opacity-50', 'cursor-not-allowed');
    }

    function handlePorcupineError(error) {
      console.error('Porcupine error:', error);
    }

    function handleLeopardError(error) {
      console.error('Leopard error:', error);
    }

    function handlePorcupineDetection(event) {
      if (event.data.command === 'ppn-keyword') {
        console.log('Wake word detected!');
        state.wakeWordDetected = true;
        handleWakeWordDetected();
      }
    }

    function handleLeopardTranscription(event) {
      if (event.data.command === 'lpd-transcription') {
        const { transcript, isComplete } = event.data;
        if (isComplete && transcript.trim()) {
          console.log('Transcription:', transcript);
          handleTranscript(transcript);
        }
      }
    }

    function handleWakeWordDetected() {
      if (state.waitingForCommand) return;
      
      state.waitingForCommand = true;
      updateMicBadge(true, true);
      
      // Add wake message
      addUserMessage('Hey Dobby');
      
      // Respond and start listening for command
      const greeting = "Hi there! What can I help you with today?";
      addBotMessage(greeting);
      speak(greeting, undefined);
      
      // Reset wake word flag
      state.wakeWordDetected = false;
    }

    // ====== Helpers ======
    function addUserMessage(text) {
      const row = document.createElement('div');
      row.className = 'flex gap-4 justify-end animate-fade-in';
      row.innerHTML = `
        <div class="max-w-[85%] bg-emerald-500 text-white rounded-3xl rounded-br-lg p-6 shadow-xl">
          <div class="leading-relaxed">${escapeHtml(text)}</div>
        </div>
        <div class="w-12 h-12 bg-gray-300 dark:bg-gray-700 rounded-2xl flex items-center justify-center text-xl shadow-lg">👤</div>
      `;
      chat.appendChild(row);
      scrollToBottom();
    }

    function addBotMessage(content, isTyping = false) {
      const row = document.createElement('div');
      row.className = 'flex gap-4 animate-fade-in';
      row.innerHTML = `
        <img 
          src="dobby-logo.png" 
          alt="Dobby Logo" 
          class="dobby-logo shadow-lg"
          onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'"
        />
        <div class="w-12 h-12 bg-emerald-500 rounded-2xl flex items-center justify-center text-white text-xl shadow-lg" style="display: none;">🤖</div>
        <div class="max-w-[85%] glass rounded-3xl rounded-bl-lg p-6 shadow-xl">
          <div class="botContent text-white leading-relaxed">${isTyping ? '' : content}</div>
        </div>
      `;
      chat.appendChild(row);
      scrollToBottom();
      return row.querySelector('.botContent');
    }

    function showTyping() {
      typingIndicator.classList.remove('hidden');
      scrollToBottom();
    }

    function hideTyping() {
      typingIndicator.classList.add('hidden');
    }

    function scrollToBottom() {
      setTimeout(() => {
        chat.scrollTop = chat.scrollHeight;
      }, 100);
    }

    function updateMicBadge(active, waiting = false) {
      if (waiting) {
        micBadge.className = 'w-3 h-3 rounded-full bg-blue-500 pulse-ring transition-all duration-300';
        micBadge.title = 'Waiting for command...';
      } else if (active) {
        micBadge.className = 'w-3 h-3 rounded-full bg-emerald-500 pulse-ring transition-all duration-300';
        micBadge.title = 'Listening for "Hey Dobby"...';
      } else {
        micBadge.className = 'w-3 h-3 rounded-full bg-gray-300 transition-all duration-300';
        micBadge.title = 'Mic idle';
      }
    }

    function updateVoiceStatus(status) {
      voiceStatus.textContent = status;
      if (status.includes('Listening')) {
        updateMicBadge(true, status.includes('command'));
      } else if (status === 'Voice Ready') {
        updateMicBadge(false);
      }
    }

    function escapeHtml(str = '') {
      return str.replace(/[&<>'"]/g, c => ({'&': '&amp;', '<': '&lt;', '>': '&gt;', '\'': '&#39;', '"': '&quot;'}[c]));
    }

    // ====== Voice Control Functions ======
    async function startListening() {
      if (!isInitialized) return;
      
      // Use Picovoice if available, otherwise Web Speech API
      if (webVoiceProcessor) {
        try {
          await webVoiceProcessor.start();
          state.listening = true;
          btnListen.textContent = 'Stop Listening';
          updateVoiceStatus(state.waitingForCommand ? 'Listening for command...' : 'Listening for "Hey Dobby"...');
          updateMicBadge(true, state.waitingForCommand);
        } catch (error) {
          console.error('Error starting voice processor:', error);
          updateVoiceStatus('Error starting microphone');
        }
      } else if (recognition) {
        startWebSpeechListening();
      }
    }

    async function stopListening() {
      if (!isInitialized) return;
      
      // Use Picovoice if available, otherwise Web Speech API
      if (webVoiceProcessor) {
        try {
          await webVoiceProcessor.stop();
          state.listening = false;
          state.waitingForCommand = false;
          btnListen.textContent = 'Start Listening';
          updateVoiceStatus('Voice Ready (Picovoice)');
          updateMicBadge(false);
        } catch (error) {
          console.error('Error stopping voice processor:', error);
        }
      } else if (recognition) {
          // ✅ leave Always Listening alone — the toggle owns it
          stopWebSpeechListening();
          state.listening = false;
          state.waitingForCommand = false;
          btnListen.textContent = 'Start Listening';
          updateVoiceStatus('Voice Ready (Web Speech)');
          updateMicBadge(false);
      }

    }

    // ====== Event Handlers ======
    btnListen.addEventListener('click', async () => {
      if (!isInitialized) {
        alert('Voice recognition is not available. Please check your microphone permissions or try a different browser.');
        return;
      }
      
      if (state.listening) {
        state.always = false;
        toggleAlways.checked = false;
        await stopListening();
      } else {
        await startListening();
      }
    });

    toggleAlways.addEventListener('change', async (e) => {
      state.always = !!e.target.checked;
      if (state.always && !state.listening && isInitialized) {
        await startListening();
      } else if (!state.always && state.listening) {
        await stopListening();
      }
    });

    btnSend.addEventListener('click', sendMessage);
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') sendMessage();
    });

    function sendMessage() {
    const text = input.value.trim();
    if (!text) return;
    
    // IMMEDIATELY stop listening when user sends text message
    stopListening();
    
    input.value = '';
    addUserMessage(text);
    processCommand(text);
  }

    // ====== NLP and Command Processing ======
      function handleTranscript(transcript) {
  if (isDobbySpeaking) return; // Ignore input while Dobby is speaking

  stopListening();

  const text = transcript.trim();
  if (!text || text.length < 2) return;

  if (state.waitingForCommand) {
    state.waitingForCommand = false;
    updateMicBadge(state.listening, false);
    addUserMessage(text);
    processCommand(text);
    return;
  }
  // Wake word detection is handled separately
}

// Update the processCommand function to properly use the isAnsweringUser flag

function processCommand(cmd) {
  const hasPriceKeyword = /(price|how much|quote|what's|whats|value|cost|analyze|analysis|show me)/i.test(cmd);
  let query = null;

  if (hasPriceKeyword) {
    const match = cmd.match(/(?:price\s+(?:of\s+)?|of\s+|for\s+|analyze\s+|analysis\s+(?:of\s+)?|show\s+me\s+)([a-z0-9\-\.]{2,15})/i) || 
                 cmd.match(/([a-z0-9\-\.]{2,15})(?:\s+price|\s+cost|\s+value|\s+analysis)/i);
    query = match ? match[1] : null;
  }

  if (!query) {
    const tokens = cmd.split(/\s+/).filter(t => t.length >= 2 && t.length <= 10);
    query = tokens[tokens.length - 1];
  }

  if (!query || query.length < 2) {
    const errorMsg = "I can fetch crypto prices and provide AI analysis! Try asking: 'What's the price of Bitcoin?' or 'Show me ETH analysis'.";
    addBotMessage(errorMsg);
    // Use isAnsweringUser = true so it resumes listening after error message
    speak(errorMsg, undefined, true);
    return;
  }

  showTyping();
  getCoinQuote(query)
    .then(res => {
      hideTyping();
      if (!res) {
        const errorMsg = `Sorry, I couldn't find "${query}". Try using the full name like 'bitcoin' or the symbol like 'btc'.`;
        addBotMessage(errorMsg);
        speak(errorMsg, undefined, true);
        return;
      }
      
      // Get AI insight
      getDobbyAnalysis(res).then(aiInsight => {
        const response = formatPriceResponse(res, aiInsight);
        addBotMessage(response);

        // Speak price summary first
        const priceSummary = generateSpeechText(res);
        speak(priceSummary, () => {
          // Then speak Dobby's insight
          const cleanedInsight = cleanDobbyAnalysis(aiInsight || generateBasicAdvice(res.change24h, res.vol24h));
          if (cleanedInsight) {
            const insightIntro = "Here is my professional AI insight. " + cleanedInsight;
            // This is the final speech - set isAnsweringUser = true to resume listening
            speak(insightIntro, undefined, true);
          }
        }, false); // First speech is not the final answer
        
      }).catch(err => {
        console.error('AI Analysis Error:', err);
        const response = formatPriceResponse(res, null);
        addBotMessage(response);
        const priceSummary = generateSpeechText(res);
        // This is the only speech - set isAnsweringUser = true
        speak(priceSummary, undefined, true);
      });
    })
    .catch(err => {
      hideTyping();
      console.error('API Error:', err);
      const errorMsg = "Oops! Something went wrong fetching the data. Please try again in a moment.";
      addBotMessage(errorMsg);
      speak(errorMsg, undefined, true);
    });
}


// Update handleWebSpeechTranscript to use the new pattern
  // In handleWebSpeechTranscript, ignore all input if Dobby is speaking
function handleWebSpeechTranscript(raw) {
  if (isDobbySpeaking) return; // Ignore input while Dobby is speaking

  stopListening();

  const heard = raw.toLowerCase().trim();
  const words = heard.split(/\s+/);
  const firstWord = words[0];
  const wakeWords = ["hey", "a", "i", "hello", "hi", "adobe", "aw"];

    // If waiting for command, process it
    if (state.waitingForCommand) {
      state.waitingForCommand = false;

      // Custom: Update user message for "a" or "i"
      let displayText = raw;
      if (firstWord === "a" || firstWord === "adobe" || firstWord === "aw" || firstWord === "Adobe" || firstWord === "Aw") {
        displayText = "Hey Dobby, " + words.slice(1).join(" ");
      } else if (firstWord === "i") {
        displayText = "Hi Dobby, " + words.slice(1).join(" ");
      }

      addUserMessage(displayText);
      processCommand(raw);
      return;
    }

    if (!wakeWords.includes(firstWord)) return;

    let cmd = words.slice(1).join(" ").trim();

    if (!cmd || cmd.length < 2) {
      // Just a wake word without command
      let displayText = firstWord;
      if (firstWord === "a") {
        displayText = "Hey Dobby,";
      } else if (firstWord === "i") {
        displayText = "Hi Dobby,";
      }

      addUserMessage(displayText);
      const greeting = "Hi there! What can I help you with today?";
      addBotMessage(greeting);

      // Don't set isAnsweringUser = true for greeting, we want to wait for command
      speak(greeting, () => {
        // After greeting, start listening for the actual command
        state.waitingForCommand = true;
        updateMicBadge(true, true);
        if (state.always || state.listening) {
          startListening();
        }
      }, false);
      return;
    }

    // Wake word + command in one phrase
    let displayText = raw;
    if (firstWord === "a") {
      displayText = "Hey Dobby, " + cmd;
    } else if (firstWord === "i") {
      displayText = "Hi Dobby, " + cmd;
    }

    addUserMessage(displayText);
    processCommand(cmd);
  }

// Update respondWithError to properly handle listening resumption
function respondWithError(message) {
  addBotMessage(message);
  // Set isAnsweringUser = true so listening resumes after error message
  speak(message, undefined, true);
}

    // ====== Dobby AI Integration ======
    async function getDobbyAnalysis(coinData) {
      if (!DOBBY_KEY || DOBBY_KEY === 'your-dobby-api-key-here') {
        return "AI analysis requires API key configuration. Using basic insights instead.";
      }

      const { name, symbol, price, vol24h, change24h, marketCap } = coinData;
      
      const prompt = `Analyze this cryptocurrency data and provide trading insights:

Coin: ${name} (${symbol.toUpperCase()})
Current Price: ${formatPrice(price)}
24h Change: ${change24h.toFixed(2)}%
24h Volume: ${formatNumber(vol24h)}
Market Cap: ${formatNumber(marketCap)}
Timestamp: ${new Date().toISOString()}

Provide a brief but insightful analysis covering:
1. Price momentum and trend assessment
2. Volume analysis and market sentiment
3. Key support/resistance levels (if identifiable)
4. Risk assessment and trading recommendation
5. Market outlook (short-term)
5. Remember to include a technical insight or professional trading tip.
6. Don't number the points. Just keep your statements in paragraph form.

Keep it concise, actionable, and beginner-friendly. Limit to 2-3 sentences.

IMPORTANT:
- Avoid repeating the same points.
- Do not use inappropriate language or slang.
- Advise users whether to buy, hold, or sell based on data and give reasons.
- Use markdown formatting for readability


ANALYSIS:`;

      try {
        const response = await fetch("https://api.fireworks.ai/inference/v1/completions", {
          method: "POST",
          headers: {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": `Bearer ${DOBBY_KEY}`
          },
          body: JSON.stringify({
            model: "accounts/sentientfoundation-serverless/models/dobby-mini-unhinged-plus-llama-3-1-8b",
            max_tokens: 800,
            top_p: 0.8,
            top_k: 40,
            presence_penalty: 0.2,
            frequency_penalty: 0.2,
            temperature: 0.3,
            prompt: prompt,
            stop: ["\nANALYSIS COMPLETE"]
          })
        });

        if (!response.ok) {
          throw new Error(`API Error: ${response.status}`);
        }

        const data = await response.json();
        return data.choices?.[0]?.text?.trim() || "Unable to generate AI analysis at this time.";
      } catch (error) {
        console.error('Dobby AI Error:', error);
        return generateBasicAdvice(change24h, vol24h);
      }
    }

    // ...existing code...

function cleanDobbyAnalysis(aiInsight) {
  if (!aiInsight) return "";

  // Remove markdown headings and bullet points
  let cleaned = aiInsight
    .replace(/#+\s?.*\n/g, '') // Remove markdown headings
    .replace(/[*\-]\s+/g, '')  // Remove bullet points
    .replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold
    .replace(/[_`>]/g, '') // Remove other markdown
    .replace(/[\r\n]+/g, ' ') // Collapse newlines
    .replace(/\s{2,}/g, ' '); // Collapse extra spaces

  // Remove repeated sentences (simple approach)
  const sentences = cleaned.split(/(?<=[.?!])\s+/);
  const seen = new Set();
  const unique = [];
  for (const s of sentences) {
    const trimmed = s.trim();
    if (trimmed && !seen.has(trimmed.toLowerCase())) {
      // Filter out inappropriate language
      if (!/fuck|shit|rekt|cuck|yolo|balls|hell|mess|rugged|eat shit|lose your shirt/i.test(trimmed)) {
        seen.add(trimmed.toLowerCase());
        unique.push(trimmed);
      }
    }
    if (unique.length >= 3) break; // Limit to 3 sentences
  }
  return unique.join(' ');
}

// ...existing code...

function formatPriceResponse(data, aiInsight) {
  const { name, symbol, price, vol24h, change24h, marketCap } = data;
  const isPositive = change24h >= 0;
  const arrow = isPositive ? '📈' : '📉';
  const changeColor = isPositive ? 'text-emerald-400' : 'text-red-400';

  // Clean and limit the AI analysis
  const cleanedInsight = cleanDobbyAnalysis(aiInsight || generateBasicAdvice(change24h, vol24h));

  return `
    <div class="space-y-4">
      <div class="flex items-center gap-3">
        <div class="text-2xl font-bold">${name} (${symbol.toUpperCase()})</div>
        <div class="text-xl">${arrow}</div>
      </div>
      
      <div class="text-3xl font-bold text-emerald-400">
        ${formatPrice(price)}
      </div>
      
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
        <div class="bg-white/10 rounded-xl p-3">
          <div class="opacity-75">24h Change</div>
          <div class="text-lg font-semibold ${changeColor}">
            ${change24h >= 0 ? '+' : ''}${change24h.toFixed(2)}%
          </div>
        </div>
        
        <div class="bg-white/10 rounded-xl p-3">
          <div class="opacity-75">24h Volume</div>
          <div class="text-lg font-semibold">${formatNumber(vol24h)}</div>
        </div>
        
        <div class="bg-white/10 rounded-xl p-3">
          <div class="opacity-75">Market Cap</div>
          <div class="text-lg font-semibold">${formatNumber(marketCap)}</div>
        </div>
        
        <div class="bg-white/10 rounded-xl p-3">
          <div class="opacity-75">Last Updated</div>
          <div class="text-lg font-semibold">${new Date().toLocaleTimeString()}</div>
        </div>
      </div>
      
      <div class="mt-4 p-4 bg-gradient-to-r from-emerald-500/20 to-blue-500/20 rounded-xl border border-emerald-500/30">
        <div class="font-semibold text-emerald-300 mb-2 flex items-center gap-2">
          <span>🧠</span>
          <span>Dobby's AI Analysis:</span>
        </div>
        <div class="opacity-90 text-sm leading-relaxed">${cleanedInsight}</div>
      </div>
    </div>
  `;
}

// ...existing code...

    function generateSpeechText(data) {
      const { name, symbol, price, change24h } = data;
      const direction = change24h >= 0 ? 'up' : 'down';
      return `${name} is currently trading at ${formatPrice(price)} $, ${direction} ${Math.abs(change24h).toFixed(2)}% in the last 24 hours.`;
    }

    function formatPrice(price) {
      if (price >= 1) return price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      if (price >= 0.01) return price.toLocaleString(undefined, { minimumFractionDigits: 4, maximumFractionDigits: 4 });
      return price.toLocaleString(undefined, { minimumFractionDigits: 8, maximumFractionDigits: 8 });
    }

    function formatNumber(num) {
      if (num >= 1e12) return (num / 1e12).toFixed(1) + 'T';
      if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
      if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
      if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
      return num.toLocaleString();
    }

    function generateBasicAdvice(change24h, volume) {
      const absChange = Math.abs(change24h);
      
      if (absChange < 1) return "Market's showing stability today. Good consolidation phase - consider this for position building if it aligns with your strategy.";
      if (change24h > 0 && absChange < 5) return "Modest upward momentum detected. Volume suggests healthy buying interest. Good entry point for long-term holders.";
      if (change24h > 5) return "Strong bullish movement with significant gains. High volatility present - consider taking partial profits and managing risk carefully.";
      if (change24h < 0 && absChange < 5) return "Minor pullback observed. This dip could present a buying opportunity for believers in the long-term fundamentals.";
      return "High volatility detected with significant price movement. Exercise extreme caution and use proper risk management in current market conditions.";
    }

    // ====== CoinGecko API Integration ======
    const SYMBOL_TO_ID = {
      btc: 'bitcoin', eth: 'ethereum', sol: 'solana', bnb: 'binancecoin', 
      xrp: 'ripple', ada: 'cardano', doge: 'dogecoin', ton: 'the-open-network', 
      pepe: 'pepe', trx: 'tron', matic: 'polygon', arb: 'arbitrum', 
      op: 'optimism', apt: 'aptos', sui: 'sui', link: 'chainlink', 
      atom: 'cosmos', near: 'near', avax: 'avalanche-2', shib: 'shiba-inu',
      ltc: 'litecoin', bch: 'bitcoin-cash', etc: 'ethereum-classic',
      xlm: 'stellar', algo: 'algorand', vet: 'vechain', icp: 'internet-computer',
      fil: 'filecoin', aave: 'aave', uni: 'uniswap', cake: 'pancakeswap-token',
      dot: 'polkadot', luna: 'terra-luna-2', lunc: 'terra-luna',
      usdt: 'tether', usdc: 'usd-coin', busd: 'binance-usd'
    };

    // ...existing code...

async function getCoinQuote(userQuery) {
  const q = userQuery.toLowerCase().replace(/[^a-z0-9\-\.]/g, '');
  try {
    const response = await fetch(`https://api.dexscreener.com/latest/dex/search?q=${encodeURIComponent(q)}`, {
      method: 'GET',
      headers: { "Accept": "*/*" }
    });
    if (!response.ok) throw new Error(`Dexscreener API error: ${response.status}`);
    const data = await response.json();
    if (!data.pairs || !data.pairs.length) return null;

    // Pick the first matching pair
    const pair = data.pairs[0];
    const priceUsd = parseFloat(pair.priceUsd || "0");
    const change24h = pair.priceChange?.h24 ?? 0;
    const vol24h = pair.volume?.h24 ?? 0;
    const marketCap = pair.marketCap ?? pair.fdv ?? 0;

    return {
      name: pair.baseToken.name,
      symbol: pair.baseToken.symbol,
      price: priceUsd,
      vol24h: vol24h,
      change24h: change24h,
      marketCap: marketCap,
      source: 'Dexscreener',
      url: pair.url,
      chainId: pair.chainId,
      dexId: pair.dexId
    };
  } catch (e) {
    console.error('Dexscreener API Error:', e);
    return null;
  }
}

// ...existing code...

    // ====== Error Handling & Recovery ======
    window.addEventListener('error', (e) => {
      console.error('Global error:', e.error);
    });

    window.addEventListener('unhandledrejection', (e) => {
      console.error('Unhandled promise rejection:', e.reason);
    });

    // ====== Initialize App ======
    console.log('DADA - Dobby AI DeFi Assistant (Picovoice) initialized');
    
    // Initialize voice recognition when the page loads
    async function initApp() {
      // Wait a bit for all scripts to load
      setTimeout(async () => {
        await initializePicovoice();
      }, 1000);
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      initApp();
    }
  </script>
</body>
</html>